\section{Week 9: Regular Expressions and Finite Automata}

\textit{Or: ``Pattern matching and the simplest model of computation''}

\subsection*{Reading}
Epp \S 12.1--12.3. Supplemental: CFGs and PDAs.\\
\textbf{Category theory companion:} Week 9 (\texttt{category\_theory\_companion.pdf}).

\subsection*{Why Automata Theory?}

Every programmer uses regular expressions: searching text, validating input, parsing logs. But regex is more than a practical tool---it's a window into the theory of computation.

Finite automata are the simplest computational model: machines with finite memory that read input symbol by symbol and either accept or reject. Remarkably, these simple machines capture exactly the same patterns as regular expressions. This equivalence is beautiful and useful.

But finite automata can't do everything. Some patterns---like ``balanced parentheses'' or ``equal numbers of 0s and 1s''---are provably impossible for them. Understanding \emph{why} reveals fundamental limits of computation and motivates more powerful models.

\subsection*{Learning objectives}
\begin{itemize}
  \item Define languages, alphabets, and strings.
  \item Construct regular expressions to describe languages.
  \item Build deterministic finite automata (DFAs) and trace their execution.
  \item Convert between regular expressions and DFAs.
  \item Minimize DFAs by merging equivalent states.
  \item Use the pumping lemma to prove non-regularity.
\end{itemize}

\subsection*{Key definitions and facts}

\subsubsection*{Languages and Strings}

\begin{definition}[Alphabet, string, language]
\begin{itemize}
  \item An \textbf{alphabet} $\Sigma$ is a finite, nonempty set of symbols.
  \item A \textbf{string} (or word) over $\Sigma$ is a finite sequence of symbols from $\Sigma$.
  \item The \textbf{empty string} $\varepsilon$ has length 0.
  \item $\Sigma^*$ denotes all strings over $\Sigma$ (including $\varepsilon$).
  \item A \textbf{language} over $\Sigma$ is a subset $L \subseteq \Sigma^*$.
\end{itemize}
\end{definition}

Languages can be finite or infinite. The language ``all binary strings of length 3'' is finite (8 strings). The language ``all binary strings starting with 1'' is infinite.

\begin{definition}[String operations]
\begin{itemize}
  \item \textbf{Length}: $|w|$ is the number of symbols in $w$.
  \item \textbf{Concatenation}: $w_1 w_2$ appends $w_2$ to $w_1$. Note: $w\varepsilon = \varepsilon w = w$.
  \item \textbf{Exponentiation}: $w^n = \underbrace{ww \cdots w}_{n \text{ times}}$; $w^0 = \varepsilon$.
  \item \textbf{Reversal}: $w^R$ is $w$ written backwards.
\end{itemize}
\end{definition}

\begin{definition}[Language operations]
For languages $L, L_1, L_2 \subseteq \Sigma^*$:
\begin{itemize}
  \item \textbf{Union}: $L_1 \cup L_2$ --- strings in either language
  \item \textbf{Concatenation}: $L_1 L_2 = \{w_1 w_2 : w_1 \in L_1, w_2 \in L_2\}$ --- all ways to concatenate
  \item \textbf{Kleene star}: $L^* = \{\varepsilon\} \cup L \cup L^2 \cup L^3 \cup \cdots$ --- zero or more repetitions
  \item \textbf{Kleene plus}: $L^+ = L \cup L^2 \cup L^3 \cup \cdots = LL^*$ --- one or more repetitions
\end{itemize}
\end{definition}

\subsection*{Regular expressions}

\begin{definition}[Regular expression]
A \textbf{regular expression} (regex) over alphabet $\Sigma$ is defined recursively:
\begin{enumerate}
  \item $\emptyset$ denotes the empty language $\{\}$ (no strings).
  \item $\varepsilon$ denotes the language $\{\varepsilon\}$ (just the empty string).
  \item For each $a \in \Sigma$, $a$ denotes the language $\{a\}$.
  \item If $r_1$ and $r_2$ are regexes:
  \begin{itemize}
    \item $(r_1 \mid r_2)$ denotes $L(r_1) \cup L(r_2)$ (union/alternation)
    \item $(r_1 r_2)$ denotes $L(r_1) L(r_2)$ (concatenation)
    \item $(r_1)^*$ denotes $L(r_1)^*$ (Kleene star)
  \end{itemize}
\end{enumerate}
\end{definition}

\begin{definition}[Precedence]
Operator precedence (highest to lowest): Kleene star $*$, concatenation, union $\mid$.

So $ab^*\mid c$ means $(a(b^*))\mid c$---not $(ab)^* \mid c$ or $a(b^* \mid c)$.
\end{definition}

\begin{example}[Common regex patterns]
Over $\Sigma = \{0, 1\}$:
\begin{itemize}
  \item All strings: $(0 \mid 1)^*$
  \item Strings starting with 1: $1(0 \mid 1)^*$
  \item Strings ending with 01: $(0 \mid 1)^*01$
  \item Exactly one 1: $0^*10^*$
  \item At least one 0: $(0 \mid 1)^*0(0 \mid 1)^*$
  \item Even-length strings: $((0 \mid 1)(0 \mid 1))^*$
\end{itemize}
\end{example}

\subsection*{Deterministic finite automata}

\begin{definition}[DFA]
A \textbf{deterministic finite automaton} (DFA) is a 5-tuple $(Q, \Sigma, \delta, q_0, F)$ where:
\begin{itemize}
  \item $Q$ is a finite set of \textbf{states}
  \item $\Sigma$ is the input \textbf{alphabet}
  \item $\delta: Q \times \Sigma \to Q$ is the \textbf{transition function}
  \item $q_0 \in Q$ is the \textbf{start state}
  \item $F \subseteq Q$ is the set of \textbf{accept states}
\end{itemize}
\end{definition}

A DFA is ``deterministic'' because from any state, each input symbol leads to exactly one next state. No choices, no ambiguity.

\begin{definition}[DFA execution]
A DFA \textbf{accepts} string $w = a_1 a_2 \cdots a_n$ if there's a sequence of states $r_0, r_1, \ldots, r_n$ such that:
\begin{enumerate}
  \item $r_0 = q_0$ (start in the start state)
  \item $r_{i+1} = \delta(r_i, a_{i+1})$ (follow transitions)
  \item $r_n \in F$ (end in an accept state)
\end{enumerate}
The \textbf{language} $L(M)$ is the set of strings $M$ accepts.
\end{definition}

\begin{definition}[State diagram]
A DFA can be drawn as a directed graph:
\begin{itemize}
  \item Vertices are states
  \item Edge from $q$ to $q'$ labeled $a$ means $\delta(q, a) = q'$
  \item An arrow from nowhere points to the start state
  \item Accept states have double circles
\end{itemize}
\end{definition}

\subsection*{Nondeterministic finite automata}

\begin{definition}[NFA]
A \textbf{nondeterministic finite automaton} (NFA) relaxes the DFA rules:
\begin{itemize}
  \item Transition function: $\delta: Q \times (\Sigma \cup \{\varepsilon\}) \to \Pow(Q)$
  \item From a state, there can be 0, 1, or many transitions on the same symbol
  \item $\varepsilon$-transitions allow state changes without consuming input
\end{itemize}
An NFA accepts if \emph{some} computational path leads to an accept state.
\end{definition}

NFAs seem more powerful---they can ``guess'' the right path. But they're not.

\begin{theorem}[NFA-DFA equivalence]
For every NFA, there's a DFA accepting the same language. The \textbf{subset construction} converts an $n$-state NFA to a DFA with at most $2^n$ states.
\end{theorem}

The subset construction treats sets of NFA states as single DFA states. It tracks all possible states the NFA might be in.

\subsection*{Regular languages}

\begin{definition}[Regular language]
A language is \textbf{regular} if it's recognized by some DFA (equivalently, by some NFA, or described by some regex).
\end{definition}

\begin{theorem}[Kleene's theorem]
For a language $L$, the following are equivalent:
\begin{enumerate}
  \item $L$ is described by a regular expression.
  \item $L$ is recognized by a DFA.
  \item $L$ is recognized by an NFA.
\end{enumerate}
\end{theorem}

This is a remarkable three-way equivalence. Three different formalisms---algebraic (regex), operational (DFA), and nondeterministic (NFA)---capture exactly the same class of languages.

\begin{theorem}[Closure properties]
Regular languages are closed under:
\begin{itemize}
  \item Union, concatenation, Kleene star (by definition of regex)
  \item Complement: swap accept/non-accept states in DFA
  \item Intersection: $L_1 \cap L_2 = \overline{\overline{L_1} \cup \overline{L_2}}$ (De Morgan)
  \item Reversal: reverse all transitions and swap start/accept
\end{itemize}
\end{theorem}

\subsection*{DFA minimization}

Different DFAs can recognize the same language. Is there a ``best'' one?

\begin{definition}[Equivalent states]
States $p$ and $q$ are \textbf{equivalent} if for all strings $w$:
\[
\hat{\delta}(p, w) \in F \iff \hat{\delta}(q, w) \in F
\]
Equivalent states are indistinguishable---no input can tell them apart.
\end{definition}

\begin{theorem}[Minimization]
Every regular language has a unique minimum-state DFA (up to isomorphism), obtained by merging equivalent states.
\end{theorem}

\begin{definition}[Table-filling algorithm]
To find equivalent states:
\begin{enumerate}
  \item Mark pairs $(p, q)$ where exactly one is in $F$ as distinguishable.
  \item Repeat: Mark $(p, q)$ if for some $a \in \Sigma$, $(\delta(p,a), \delta(q,a))$ is already marked.
  \item Unmarked pairs are equivalent; merge them.
\end{enumerate}
\end{definition}

\subsection*{Non-regular languages}

Not all languages are regular. The pumping lemma helps prove this.

\begin{theorem}[Pumping lemma for regular languages]
If $L$ is regular, there exists a ``pumping length'' $p$ such that any string $w \in L$ with $|w| \geq p$ can be split as $w = xyz$ where:
\begin{enumerate}
  \item $|y| > 0$ (the ``pump'' is non-empty)
  \item $|xy| \leq p$ (the pump is near the start)
  \item For all $i \geq 0$, $xy^iz \in L$ (pumping preserves membership)
\end{enumerate}
\end{theorem}

The intuition: if a DFA reads a long enough string, it must revisit some state. The substring between visits can be repeated (or removed) without changing acceptance.

\begin{strategy}
To prove $L$ is not regular:
\begin{enumerate}
  \item Assume $L$ is regular (for contradiction).
  \item Let $p$ be the pumping length.
  \item Choose $w \in L$ with $|w| \geq p$ (often depending on $p$).
  \item Show that for any split $w = xyz$ satisfying conditions 1 and 2, some $xy^iz \notin L$.
  \item Contradiction: $L$ is not regular.
\end{enumerate}
\end{strategy}

\subsection*{Context-free grammars}

Regular languages can't handle nested structure. Context-free grammars can.

\begin{definition}[Context-free grammar]
A CFG is a 4-tuple $(V, \Sigma, R, S)$ where:
\begin{itemize}
  \item $V$ is a set of variables (nonterminals)
  \item $\Sigma$ is a set of terminals (the alphabet)
  \item $R$ is a set of production rules $A \to \alpha$ where $A \in V$ and $\alpha \in (V \cup \Sigma)^*$
  \item $S \in V$ is the start symbol
\end{itemize}
The language $L(G)$ is all strings derivable from $S$.
\end{definition}

\begin{definition}[Derivation]
We write $S \Rightarrow^* w$ if $w$ can be derived from $S$ by repeatedly applying rules.
A \textbf{parse tree} records the derivation structure.
\end{definition}

\begin{example}
The grammar $S \to aSb \mid \varepsilon$ generates $L = \{a^n b^n : n \geq 0\}$.

Derivation of $aabb$: $S \Rightarrow aSb \Rightarrow aaSbb \Rightarrow aabb$.
\end{example}

\begin{remark}
A grammar is \textbf{ambiguous} if some string has multiple parse trees. Ambiguity complicates parsing and semantics.
\end{remark}

\subsection*{Pushdown automata}

\begin{definition}[Pushdown automaton (PDA)]
A \textbf{pushdown automaton} is an NFA with a stack. It can push, pop, or read the stack top when transitioning.
\end{definition}

\begin{theorem}[CFG-PDA equivalence]
A language is context-free if and only if it's recognized by a pushdown automaton.
\end{theorem}

The stack provides unbounded memory (unlike the finite memory of DFAs), enabling recognition of nested structures.

\subsection*{Worked examples}

\begin{example}[DFA for even number of 0s]
Design a DFA over $\{0, 1\}$ that accepts strings with an even number of 0s.

\emph{Solution.} Two states: $q_e$ (even 0s seen) and $q_o$ (odd 0s seen).
\begin{itemize}
  \item Start state: $q_e$ (zero 0s is even)
  \item Accept states: $\{q_e\}$
  \item Transitions: On 0, toggle. On 1, stay.
\end{itemize}

Formally: $\delta(q_e, 0) = q_o$, $\delta(q_o, 0) = q_e$, $\delta(q_e, 1) = q_e$, $\delta(q_o, 1) = q_o$.
\end{example}

\begin{example}[Regex for strings ending in 01]
Write a regex for binary strings ending with 01.

\emph{Solution.} $(0 \mid 1)^*01$

Any sequence, followed by 01.
\end{example}

\begin{example}[DFA for no substring $bb$]
Construct a DFA over $\{a, b\}$ accepting strings with no $bb$ substring.

\emph{Solution.} Three states tracking recent history:
\begin{itemize}
  \item $q_0$: Start, or last symbol was $a$
  \item $q_1$: Last symbol was $b$
  \item $q_{\text{dead}}$: Saw $bb$, reject forever
\end{itemize}

Transitions:
\begin{itemize}
  \item From $q_0$: on $a$ stay, on $b$ go to $q_1$
  \item From $q_1$: on $a$ go to $q_0$, on $b$ go to $q_{\text{dead}}$
  \item From $q_{\text{dead}}$: stay forever
\end{itemize}
Accept states: $\{q_0, q_1\}$.
\end{example}

\begin{example}[Intersection of regular languages]
Prove that the intersection of two regular languages is regular.

\emph{Solution.} Let $L_1$ have DFA $M_1 = (Q_1, \Sigma, \delta_1, q_1, F_1)$ and $L_2$ have $M_2 = (Q_2, \Sigma, \delta_2, q_2, F_2)$.

Build the product DFA $M = (Q_1 \times Q_2, \Sigma, \delta, (q_1, q_2), F_1 \times F_2)$ where:
\[
\delta((p, q), a) = (\delta_1(p, a), \delta_2(q, a))
\]
$M$ accepts $w$ iff both $M_1$ and $M_2$ accept $w$, so $L(M) = L_1 \cap L_2$.
\end{example}

\begin{example}[DFA minimization]
Minimize a DFA with states $\{A, B, C, D\}$, start $A$, accept $\{C\}$, transitions:
$\delta(A,0)=B$, $\delta(A,1)=C$, $\delta(B,0)=B$, $\delta(B,1)=C$, $\delta(C,0)=D$, $\delta(C,1)=C$, $\delta(D,0)=D$, $\delta(D,1)=C$.

\emph{Solution.} Using table-filling:
\begin{enumerate}
  \item Mark $(A,C), (B,C), (D,C)$ (accept vs non-accept).
  \item Check $(A,B)$: $\delta(A,0)=B$, $\delta(B,0)=B$ (same); $\delta(A,1)=C$, $\delta(B,1)=C$ (same). Not distinguishable.
  \item Check $(A,D)$ and $(B,D)$: similarly not distinguishable.
  \item $A$, $B$, $D$ are equivalent. Merge them.
\end{enumerate}
Minimal DFA has 2 states: $\{A,B,D\}$ and $\{C\}$.
\end{example}

\begin{example}[Pumping lemma: $\{0^n1^n\}$]
Prove $L = \{0^n1^n : n \geq 0\}$ is not regular.

\emph{Proof.} Assume $L$ is regular with pumping length $p$.

Choose $w = 0^p1^p \in L$. Since $|w| = 2p \geq p$, the pumping lemma applies.

Write $w = xyz$ with $|y| > 0$ and $|xy| \leq p$. Since $|xy| \leq p$ and $w$ starts with $p$ zeros, $y = 0^k$ for some $k > 0$.

Consider $xy^2z = 0^{p+k}1^p$. This has more 0s than 1s, so $xy^2z \notin L$.

Contradiction. $L$ is not regular. \qed
\end{example}

\begin{example}[Regex for at least two 0s]
Write a regex for binary strings with at least two 0s.

\emph{Solution.} $(0 \mid 1)^* 0 (0 \mid 1)^* 0 (0 \mid 1)^*$

Two 0s, with anything before, between, and after.
\end{example}

\begin{example}[DFA for divisibility by 3]
Design a DFA for binary strings representing numbers divisible by 3.

\emph{Solution.} Track value mod 3 as we read bits left-to-right. If current value is $v$ and we read bit $b$, new value is $2v + b \pmod 3$.

States $q_0, q_1, q_2$ for value mod 3.
\begin{itemize}
  \item Start: $q_0$ (value 0)
  \item Accept: $\{q_0\}$
  \item From $q_0$: on 0 go to $q_0$, on 1 go to $q_1$
  \item From $q_1$: on 0 go to $q_2$, on 1 go to $q_0$
  \item From $q_2$: on 0 go to $q_1$, on 1 go to $q_2$
\end{itemize}

Test: $110_2 = 6$. Path: $q_0 \xrightarrow{1} q_1 \xrightarrow{1} q_0 \xrightarrow{0} q_0$. Accept. \checkmark
\end{example}

\begin{example}[Pumping lemma: $\{ww\}$]
Prove $L = \{ww : w \in \{0,1\}^*\}$ is not regular.

\emph{Proof.} Assume $L$ is regular with pumping length $p$.

Choose $s = 0^p 1 0^p 1 \in L$ (where $w = 0^p 1$). We have $|s| \geq p$.

Write $s = xyz$ with $|y| > 0$, $|xy| \leq p$. Since $|xy| \leq p$ and $s$ starts with $p$ zeros, $y = 0^k$ for some $k \geq 1$.

Consider $xy^0z = 0^{p-k} 1 0^p 1$. The first half has $p-k$ zeros before its 1; the second has $p$ zeros. Since $k \geq 1$, these halves differ, so $xy^0z \notin L$.

Contradiction. $L$ is not regular. \qed
\end{example}

\begin{commonmistake}
\textbf{Confusing $\emptyset$ and $\varepsilon$.} $\emptyset$ is the empty language (no strings accepted). $\varepsilon$ is the language containing exactly the empty string. They're very different: $|\emptyset| = 0$ but $|\{\varepsilon\}| = 1$.
\end{commonmistake}

\begin{commonmistake}
\textbf{Using pumping lemma to prove regularity.} The pumping lemma only proves non-regularity. Satisfying the pumping condition is necessary but not sufficient for regularity.
\end{commonmistake}

\begin{goingdeeper}[Going Deeper: Duality and Observation]
Week 8 introduced \emph{initial algebras} for building recursive data. This week, we glimpse the dual: \emph{coalgebras} for observing behavior.
For more detail, see the Category Theory Companion, Week 9.

\subsubsection*{Algebras vs Coalgebras}

Recall: an algebra has a structure map $F(A) \to A$---it builds up data:
\begin{itemize}
  \item List algebra: $([], \text{cons})$ tells how to construct lists
  \item Tree algebra: $(\text{leaf}, \text{node})$ tells how to construct trees
\end{itemize}

A coalgebra reverses the arrow: $A \to F(A)$---it \emph{observes} or decomposes:
\begin{itemize}
  \item Given a state, observe something about it
  \item The arrow points ``outward''
\end{itemize}

\subsubsection*{DFAs as Coalgebras}

A DFA state can be observed:
\begin{enumerate}
  \item Is it accepting? (Output: yes/no)
  \item Where does each input lead? (Transitions)
\end{enumerate}

This gives a function: $Q \to \{0, 1\} \times Q^\Sigma$.

A DFA is a coalgebra for this pattern. The accept/reject output and transition structure are observations we can make of any state.

\subsubsection*{Automata as Monoid Actions}

The set $\Sigma^*$ of all strings forms a \textbf{monoid} under concatenation. A DFA extends transitions to whole strings:
\[
\delta^*: Q \times \Sigma^* \to Q
\]
This is a \emph{monoid action}: the monoid $\Sigma^*$ acts on the state set $Q$. Categorically, it's a functor from the one-object category $\Sigma^*$ to $\Set$.

\subsubsection*{Streams: Another Coalgebra}

An infinite stream can be observed:
\begin{enumerate}
  \item What's the first element? (head)
  \item What's the rest? (tail)
\end{enumerate}

Structure: $\text{Stream}(A) \to A \times \text{Stream}(A)$.

Contrast with lists: lists are built up (algebra), streams are observed (coalgebra).

\subsubsection*{The Duality Pattern}

\begin{center}
\begin{tabular}{lcc}
& \textbf{Algebra} & \textbf{Coalgebra} \\
\hline
Structure map & $F(A) \to A$ & $A \to F(A)$ \\
Intuition & Constructors & Observers \\
Universal object & Initial & Final \\
Universal map & Fold & Unfold \\
Data & Finite & Potentially infinite \\
Example & Lists, trees & Streams, automata
\end{tabular}
\end{center}

\subsubsection*{Bisimulation}

Two DFA states are \emph{bisimilar} if no observations distinguish them:
\begin{itemize}
  \item Same accept/reject status
  \item Transitions lead to bisimilar states
\end{itemize}

This is exactly what DFA minimization computes: merge bisimilar states.

\subsubsection*{Exercises: Duality and Observation}

\begin{enumerate}
  \item For an infinite stream $[0, 1, 2, 3, \ldots]$, what is $\text{head}(\text{tail}(\text{tail}(\cdot)))$?

  \item For the ``even 0s'' DFA, write out the coalgebra structure: for each state, give $(\text{accept?}, \text{transitions})$.

  \item Why can infinite streams exist but (in a total language) not ``infinite lists''?

  \item In DFA minimization, states $A$, $B$, $D$ were merged. Verify $A$ and $B$ are bisimilar.

  \item \textbf{Challenge}: The Brzozowski derivative $\partial_a(L) = \{w : aw \in L\}$ is the ``observe a transition'' operation. Show this matches the coalgebra view.
\end{enumerate}
\end{goingdeeper}

\subsection*{Practice}
\begin{enumerate}
  \item Write a regex for binary strings ending with 01.

  \item Construct a DFA for strings over $\{a, b\}$ containing no $bb$ substring.

  \item Minimize a 4-state DFA of your choosing.

  \item Prove that the intersection of two regular languages is regular.

  \item Write a regex for binary strings with at least two 0s.

  \item Design a DFA accepting strings where the number of $a$s is divisible by 3.

  \item Prove that palindromes $L = \{w : w = w^R\}$ over $\{0,1\}$ are not regular.

  \item Convert the regex $(a \mid b)^*aba$ to an NFA.

  \item Show that if $L$ is regular, then $L^R = \{w^R : w \in L\}$ is regular.

  \item Design a DFA for binary strings representing numbers divisible by 3.

  \item Prove that $L = \{a^{n^2} : n \geq 0\}$ is not regular.

  \item Given DFAs for $L_1$ and $L_2$, construct a DFA for $L_1 \setminus L_2$.

  \item Give a CFG for $\{0^n1^n : n \geq 0\}$ and derive 000111.

  \item Show the grammar $S \to SS \mid a$ is ambiguous by finding two parse trees for $aa$.

  \item Describe a PDA for $\{a^n b^n : n \geq 0\}$ and trace its stack on input $aabb$.
\end{enumerate}
