\section{Week 8: Trees and Graph Algorithms}

\textit{Or: ``The simplest connected graphs, and how to navigate them efficiently''}

\subsection*{Reading}
Epp \S 10.4--10.6. Supplemental: matchings and flows.\\
\textbf{Category theory companion:} Week 8 (\texttt{category\_theory\_companion.pdf}).

\subsection*{Why Trees?}

Trees are the ``Goldilocks'' graphs: they have just enough edges to be connected, but no more. Remove any edge and the graph falls apart. Add any edge and you create a cycle. This makes them the simplest connected structures, and remarkably useful.

File systems are trees. Organizational hierarchies are trees. Parse trees show how programs are structured. Decision trees guide classification. Family trees (well, directed acyclic graphs, really) trace ancestry. Binary search trees enable fast lookup. Spanning trees let us navigate networks efficiently.

The recursive structure of trees---a tree is either a single node or a node with subtrees---makes them perfect for recursive algorithms. This week we'll see how this structure leads to elegant solutions for shortest paths, minimum spanning trees, and more.

\subsection*{Learning objectives}
\begin{itemize}
  \item Identify trees, forests, and rooted trees.
  \item Use characterizations of trees (connected + acyclic, $|E| = |V| - 1$, etc.).
  \item Understand $m$-ary trees and binary trees.
  \item Find spanning trees using BFS and DFS.
  \item Apply shortest-path algorithms (Dijkstra's, Bellman-Ford).
  \item Find minimum spanning trees (Prim's, Kruskal's).
\end{itemize}

\subsection*{Key definitions and facts}

\subsubsection*{What Makes a Tree a Tree?}

\begin{definition}[Tree]
A \textbf{tree} is a connected graph with no cycles. A \textbf{forest} is a graph with no cycles---each connected component is a tree.
\end{definition}

\begin{theorem}[Characterizations of trees]
For a graph $G$ on $n$ vertices, the following are equivalent:
\begin{enumerate}
  \item $G$ is a tree (connected and acyclic).
  \item $G$ is connected and has exactly $n - 1$ edges.
  \item $G$ is acyclic and has exactly $n - 1$ edges.
  \item There is exactly one path between any two vertices.
  \item $G$ is connected, but removing any edge disconnects it.
  \item $G$ is acyclic, but adding any edge creates exactly one cycle.
\end{enumerate}
\end{theorem}

These characterizations reveal the ``barely connected'' nature of trees. With $n-1$ edges, you have the minimum needed for connectivity. One fewer and you're disconnected; one more and you have redundancy (a cycle).

\begin{definition}[Rooted tree]
A \textbf{rooted tree} designates one vertex as the \textbf{root}, inducing a parent-child hierarchy: every non-root vertex has a unique parent (the neighbor closer to the root) and zero or more children.
\begin{itemize}
  \item \textbf{Depth} of a vertex: distance from the root.
  \item \textbf{Height} of the tree: maximum depth.
  \item \textbf{Leaf}: a vertex with no children.
  \item \textbf{Internal vertex}: a vertex with at least one child.
\end{itemize}
\end{definition}

The same underlying tree can be rooted at different vertices, producing different hierarchies. The choice of root is a choice of perspective.

\begin{definition}[$m$-ary tree]
An \textbf{$m$-ary tree} is a rooted tree where every internal vertex has at most $m$ children.
\begin{itemize}
  \item \textbf{Binary tree}: $m = 2$ (at most two children each).
  \item \textbf{Full $m$-ary tree}: every internal vertex has exactly $m$ children.
  \item \textbf{Complete $m$-ary tree}: full, with all leaves at the same depth.
\end{itemize}
\end{definition}

\begin{theorem}[Properties of full $m$-ary trees]
For a full $m$-ary tree with $i$ internal vertices:
\begin{enumerate}
  \item Total vertices: $n = mi + 1$
  \item Leaves: $\ell = (m-1)i + 1$
  \item Internal vertices: $i = \frac{n-1}{m} = \frac{\ell - 1}{m - 1}$
\end{enumerate}
\end{theorem}

\begin{theorem}[Height bounds for binary trees]
A binary tree with $\ell$ leaves has height $h$ satisfying:
\[
\lceil \log_2 \ell \rceil \leq h \leq \ell - 1
\]
Minimum height: complete binary tree (perfectly balanced).
Maximum height: a degenerate ``linear'' tree (essentially a linked list).
\end{theorem}

This is why balanced trees matter: the difference between $O(\log n)$ and $O(n)$ operations.

\begin{definition}[Spanning tree]
A \textbf{spanning tree} of a connected graph $G$ is a subgraph that's a tree containing all vertices of $G$.
\end{definition}

\begin{theorem}[Existence of spanning trees]
Every connected graph has a spanning tree.
\end{theorem}

The proof is constructive: if there's a cycle, remove an edge from it. The graph stays connected (the cycle provided redundancy). Repeat until no cycles remain. You have a spanning tree.

\subsection*{Tree traversals}

\begin{definition}[Binary tree traversals]
Three classic ways to visit every node in a binary tree:
\begin{itemize}
  \item \textbf{Preorder}: Visit root, traverse left subtree, traverse right subtree.
  \item \textbf{Inorder}: Traverse left subtree, visit root, traverse right subtree.
  \item \textbf{Postorder}: Traverse left subtree, traverse right subtree, visit root.
\end{itemize}
\end{definition}

The names describe when you visit the root relative to its children. Preorder visits the root first (``pre''), inorder visits it between children (``in''), postorder visits it last (``post'').

For a binary search tree, inorder traversal yields elements in sorted order. This isn't a coincidence---it's why we call it ``in order.''

\begin{definition}[BFS and DFS]
\begin{itemize}
  \item \textbf{Breadth-First Search (BFS)}: Explore vertices layer by layer---all vertices at distance 1 from start, then distance 2, etc. Uses a queue.
  \item \textbf{Depth-First Search (DFS)}: Plunge as deep as possible before backtracking. Uses a stack (or recursion, which implicitly uses the call stack).
\end{itemize}
Both produce spanning trees of connected graphs.
\end{definition}

BFS finds shortest paths (in unweighted graphs). DFS finds paths, but not necessarily shortest ones---it just finds \emph{a} path.

\subsection*{Shortest path algorithms}

\begin{definition}[Weighted graph]
A \textbf{weighted graph} assigns a weight $w(e)$ to each edge. The weight of a path is the sum of its edge weights.
\end{definition}

\begin{definition}[Shortest path problem]
Given a weighted graph and vertices $s$ and $t$, find a path from $s$ to $t$ with minimum total weight.
\end{definition}

\begin{theorem}[Dijkstra's algorithm]
For graphs with non-negative edge weights, Dijkstra's algorithm finds shortest paths from a source to all other vertices.

\textbf{Idea}: Maintain a set of vertices with known shortest distances. Repeatedly add the closest unvisited vertex, updating its neighbors' tentative distances.

\textbf{Complexity}: $O((|V| + |E|) \log |V|)$ with a priority queue.
\end{theorem}

Dijkstra is greedy: it commits to the closest vertex, confident that no later discovery will provide a shorter path. This confidence is justified only when all weights are non-negative.

\begin{theorem}[Bellman-Ford algorithm]
For graphs with possibly negative edges (but no negative cycles), Bellman-Ford finds shortest paths from a source.

\textbf{Idea}: Relax all edges $|V| - 1$ times. ``Relaxing'' an edge means checking if we found a shorter path through it.

\textbf{Complexity}: $O(|V| \cdot |E|)$.
\end{theorem}

Slower than Dijkstra, but handles negative weights. It can also detect negative cycles (if relaxation still improves after $|V| - 1$ rounds, there's a negative cycle).

\begin{theorem}[Floyd-Warshall algorithm]
Finds shortest paths between \emph{all} pairs of vertices.

\textbf{Idea}: Dynamic programming. For each vertex $k$, update all pairs $(i, j)$ to consider paths through $k$.

\textbf{Complexity}: $O(|V|^3)$.
\end{theorem}

\subsection*{Minimum spanning trees}

\begin{definition}[Minimum spanning tree (MST)]
For a connected weighted graph, a \textbf{minimum spanning tree} is a spanning tree with minimum total edge weight.
\end{definition}

MSTs are useful when you want to connect everything at minimum cost: network design, circuit layout, clustering.

\begin{theorem}[Cut property]
For any cut (partition of vertices into two sets), the minimum-weight edge crossing the cut belongs to some MST.
\end{theorem}

This is the key insight behind MST algorithms: it's always safe to include a minimum-weight edge that connects two components.

\begin{theorem}[Prim's algorithm]
Start from any vertex. Repeatedly add the minimum-weight edge connecting the growing tree to a new vertex.

\textbf{Complexity}: $O((|V| + |E|) \log |V|)$ with a priority queue.
\end{theorem}

Prim grows a single tree outward, like a drop of water spreading.

\begin{theorem}[Kruskal's algorithm]
Sort edges by weight. Add edges in order, skipping any that would create a cycle.

\textbf{Complexity}: $O(|E| \log |E|)$, dominated by sorting.
\end{theorem}

Kruskal grows a forest that gradually merges into a single tree.

\subsection*{Matchings in bipartite graphs}

\begin{definition}[Matching]
A \textbf{matching} is a set of edges with no shared endpoints---each vertex is in at most one edge. A \textbf{maximum matching} has the largest possible size. A \textbf{perfect matching} covers every vertex.
\end{definition}

Think of matchings as pairings: jobs to applicants, dancers to partners, tasks to machines.

\begin{theorem}[Hall's marriage theorem]
Let $G = (X \cup Y, E)$ be a bipartite graph. There's a matching covering all of $X$ if and only if for every subset $S \subseteq X$:
\[
|N(S)| \geq |S|
\]
where $N(S)$ is the set of neighbors of $S$ in $Y$.
\end{theorem}

In words: every subset of $X$ must have at least as many neighbors as members. If 5 people can only apply to 4 jobs, you can't match everyone.

\begin{example}
$X = \{1,2,3\}$, $Y = \{a,b,c\}$, edges $\{1a, 1b, 2b, 3b, 3c\}$.

Check Hall's condition:
\begin{itemize}
  \item $|N(\{1\})| = 2 \geq 1$ \checkmark
  \item $|N(\{2\})| = 1 \geq 1$ \checkmark
  \item $|N(\{3\})| = 2 \geq 1$ \checkmark
  \item $|N(\{1,2\})| = 2 \geq 2$ \checkmark
  \item $|N(\{2,3\})| = 2 \geq 2$ \checkmark
  \item $|N(\{1,3\})| = 3 \geq 2$ \checkmark
  \item $|N(\{1,2,3\})| = 3 \geq 3$ \checkmark
\end{itemize}
Hall's condition holds, so a matching covering $X$ exists: $\{1a, 2b, 3c\}$.
\end{example}

\begin{remark}
Maximum matchings can be found via \textbf{augmenting paths}: paths that alternate between unmatched and matched edges. Flipping along such a path increases the matching size by one.
\end{remark}

\subsection*{Network flows}

\begin{definition}[Flow network]
A \textbf{flow network} is a directed graph with a source $s$, sink $t$, and capacities $c(u,v) \geq 0$ on edges.

A \textbf{flow} assigns values $f(u,v)$ satisfying:
\begin{itemize}
  \item \textbf{Capacity constraint}: $0 \leq f(u,v) \leq c(u,v)$
  \item \textbf{Conservation}: For all $v \neq s,t$: flow in = flow out
\end{itemize}
The \textbf{value} of the flow is the total leaving $s$.
\end{definition}

\begin{definition}[Cut]
An $s$-$t$ \textbf{cut} partitions vertices into $(S, T)$ with $s \in S$ and $t \in T$. Its \textbf{capacity} is the sum of capacities from $S$ to $T$.
\end{definition}

\begin{theorem}[Max-flow min-cut]
The maximum flow value equals the minimum cut capacity.
\end{theorem}

This is a beautiful duality result. Flow can never exceed cut capacity (the cut is a bottleneck). The theorem says the bottleneck is always achievable.

\begin{remark}
The Ford-Fulkerson method finds max flow by repeatedly finding augmenting paths in the residual graph until none remain.
\end{remark}

\subsection*{Worked examples}

\begin{example}[Tree edge count by induction]
Prove that a tree on $n$ vertices has exactly $n - 1$ edges.

\emph{Proof by induction.}

\textbf{Base case}: $n = 1$. A single vertex has 0 edges. $0 = 1 - 1$. \checkmark

\textbf{Inductive step}: Assume true for trees with $k$ vertices. Let $T$ be a tree with $k + 1$ vertices.

Every tree has at least one leaf (vertex of degree 1)---if every vertex had degree $\geq 2$, following edges would eventually create a cycle.

Remove a leaf $v$ and its edge. The result $T'$ has $k$ vertices and is still a tree (removing a leaf doesn't disconnect or create cycles).

By induction, $T'$ has $k - 1$ edges. Adding back $v$'s edge gives $k$ edges for $T$.

$k = (k + 1) - 1$. \checkmark
\end{example}

\begin{example}[Leaves in a full binary tree]
A full binary tree has 15 vertices. How many are leaves?

\emph{Solution.} For full binary trees: $\ell = i + 1$ where $i$ is the number of internal vertices.

Also $n = i + \ell = 15$, so $i + (i+1) = 15$, giving $i = 7$ and $\ell = 8$.

Alternatively: $\ell = \frac{(m-1)n + 1}{m} = \frac{15 + 1}{2} = 8$.
\end{example}

\begin{example}[Maximum leaves at height $h$]
How many leaves can a full $m$-ary tree of height $h$ have?

\emph{Solution.} A complete $m$-ary tree of height $h$ has all leaves at depth $h$. At depth $d$, there are at most $m^d$ vertices. Maximum leaves: $m^h$.
\end{example}

\begin{example}[Spanning tree of $K_4$]
Find a spanning tree of $K_4$.

\emph{Solution.} $K_4$ has 4 vertices and 6 edges. A spanning tree needs 3 edges.

Keep edges $\{1,2\}, \{2,3\}, \{3,4\}$. This is the path $1-2-3-4$, a spanning tree.

(Many other choices work---there are 16 spanning trees of $K_4$.)
\end{example}

\begin{example}[Why removing an edge disconnects a tree]
Explain why removing any edge from a tree disconnects it.

\emph{Solution.} In a tree, there's exactly one path between any two vertices. Edge $\{u, v\}$ is on the unique path from $u$ to $v$. Remove it and no path remains---$u$ and $v$ become disconnected.
\end{example}

\begin{example}[Dijkstra's algorithm]
Run Dijkstra on vertices $\{A, B, C, D\}$ with weighted edges: $A$-$B$ (1), $A$-$C$ (4), $B$-$C$ (2), $B$-$D$ (5), $C$-$D$ (1). Find shortest paths from $A$.

\emph{Solution.}
\begin{enumerate}
  \item Initialize: $d[A] = 0$, others $= \infty$.
  \item Process $A$: Update $d[B] = 1$, $d[C] = 4$.
  \item Process $B$ (closest unvisited): Update $d[C] = \min(4, 1+2) = 3$, $d[D] = 6$.
  \item Process $C$: Update $d[D] = \min(6, 3+1) = 4$.
  \item Process $D$: No updates.
\end{enumerate}
Shortest distances: $A \to A$: 0, $A \to B$: 1, $A \to C$: 3, $A \to D$: 4.
\end{example}

\begin{example}[Kruskal's algorithm]
Find an MST of vertices $\{A, B, C, D\}$ with edges: $A$-$B$ (3), $A$-$C$ (1), $A$-$D$ (4), $B$-$C$ (2), $B$-$D$ (5), $C$-$D$ (6).

\emph{Solution.}
\begin{enumerate}
  \item Sort edges: $A$-$C$ (1), $B$-$C$ (2), $A$-$B$ (3), $A$-$D$ (4), $B$-$D$ (5), $C$-$D$ (6).
  \item Add $A$-$C$ (1): No cycle. MST so far: $\{A$-$C\}$.
  \item Add $B$-$C$ (2): No cycle. MST: $\{A$-$C$, $B$-$C\}$.
  \item Add $A$-$B$ (3): Would create cycle $A$-$B$-$C$-$A$. Skip.
  \item Add $A$-$D$ (4): No cycle. MST: $\{A$-$C$, $B$-$C$, $A$-$D\}$.
\end{enumerate}
Total weight: $1 + 2 + 4 = 7$.
\end{example}

\begin{example}[Tree traversals]
Give preorder, inorder, and postorder traversals of:
\begin{verbatim}
       A
      / \
     B   C
    / \
   D   E
\end{verbatim}

\emph{Solution.}
\begin{itemize}
  \item \textbf{Preorder} (root, left, right): $A, B, D, E, C$
  \item \textbf{Inorder} (left, root, right): $D, B, E, A, C$
  \item \textbf{Postorder} (left, right, root): $D, E, B, C, A$
\end{itemize}
\end{example}

\begin{example}[Forest edge count]
Prove: A forest with $n$ vertices and $k$ components has $n - k$ edges.

\emph{Solution.} Each component is a tree. If component $i$ has $n_i$ vertices, it has $n_i - 1$ edges.

Total edges: $\sum_{i=1}^k (n_i - 1) = \sum n_i - k = n - k$.
\end{example}

\begin{commonmistake}
\textbf{Using Dijkstra with negative weights.} Dijkstra assumes non-negative weights. With negative edges, it can give wrong answers. Use Bellman-Ford instead.
\end{commonmistake}

\begin{commonmistake}
\textbf{Thinking $n-1$ edges implies tree.} Having exactly $n-1$ edges is necessary but not sufficient. You also need the graph to be connected (or acyclic). A disconnected graph with $n-1$ edges is a forest, not a tree.
\end{commonmistake}

\begin{goingdeeper}[Going Deeper: Trees as Initial Algebras and the Universality of Fold]
There's a deep reason why recursive functions on trees always terminate, and why the ``fold'' pattern is universal. Trees are \emph{initial algebras}, and fold is the unique morphism from an initial object.
For more detail, see the Category Theory Companion, Week 8.

\textbf{The recursive structure of trees.} A binary tree is either:
\begin{itemize}
  \item A leaf (containing data), or
  \item A node with a left subtree and a right subtree
\end{itemize}
As an equation: $\text{Tree}(A) = A + \text{Tree}(A) \times \text{Tree}(A)$.

Here $+$ means ``or'' (disjoint union) and $\times$ means ``and'' (product). This equation \emph{defines} the type.

\textbf{Algebras for tree-building.} An ``algebra'' for this structure over set $B$ consists of:
\begin{itemize}
  \item A function $\textit{leaf}: A \to B$ (what to do with leaves)
  \item A function $\textit{node}: B \times B \to B$ (how to combine subtree results)
\end{itemize}

\textbf{The fold (catamorphism).} Given any algebra $(\textit{leaf}, \textit{node})$ over $B$, there's a \emph{unique} function $\textit{fold}: \text{Tree}(A) \to B$ satisfying:
\[
\textit{fold}(\text{Leaf } a) = \textit{leaf}(a) \qquad \textit{fold}(\text{Node } \ell\, r) = \textit{node}(\textit{fold}(\ell), \textit{fold}(r))
\]

\textbf{Examples of fold.}
\begin{itemize}
  \item \textbf{Sum leaves}: $\textit{leaf}(a) = a$, $\textit{node}(x, y) = x + y$
  \item \textbf{Count leaves}: $\textit{leaf}(a) = 1$, $\textit{node}(x, y) = x + y$
  \item \textbf{Tree height}: $\textit{leaf}(a) = 0$, $\textit{node}(x, y) = 1 + \max(x, y)$
  \item \textbf{Preorder list}: $\textit{leaf}(a) = [a]$, $\textit{node}(x, y) = x \mathbin{+\!\!+} y$
\end{itemize}

All tree traversals are folds with appropriate algebra choices.

\textbf{Why recursion terminates.} The tree type is the \emph{initial} algebra---the ``smallest'' solution to the recursive equation. Uniqueness of fold means exactly one way to recursively compute any result. If recursion didn't terminate, no function would exist. If there were multiple computation paths, uniqueness would fail.

\textbf{The pattern generalizes.}
\begin{itemize}
  \item Lists: $\text{List}(A) = 1 + A \times \text{List}(A)$. Fold is $\textit{foldr}$.
  \item Natural numbers: $\N = 1 + \N$. Fold is primitive recursion.
\end{itemize}

Understanding data as initial algebras explains why structural recursion is well-founded, enables optimizations like fold fusion, and connects programming to category theory.

\subsubsection*{Exercises: Folds and Algebras}

\begin{enumerate}
  \item The ``sum'' function on lists adds elements. What's the base case (empty list maps to what)? What's the combining function?

  \item The ``length'' function counts elements. Define it as a fold.

  \item Define \texttt{map f} as a fold. What are the base case and combining function?

  \item For natural numbers with $\text{Zero}$ and $\text{Succ}$: define addition $n + m$ by folding over $n$ with $m$ fixed.

  \item Define ``tree height'' as a fold on binary trees.

  \item Express inorder traversal as a fold. (Hint: where does the root's data go relative to left and right results?)

  \item \textbf{Challenge}: The ``fold fusion'' law says if certain conditions hold, $h \circ \textit{fold}_g = \textit{fold}_{g'}$. For lists, verify this for $h(n) = 2n$, $f(x, y) = x + y$, $z = 0$.
\end{enumerate}
\end{goingdeeper}

\subsection*{Practice}
\begin{enumerate}
  \item How many leaves can a full $m$-ary tree of height $h$ have?

  \item Find a spanning tree of $K_5$.

  \item Explain why removing any edge from a tree disconnects it.

  \item Run Dijkstra's algorithm on a 5-vertex weighted graph of your choice.

  \item A full binary tree has 31 vertices. How many are leaves? Internal vertices?

  \item Prove: Every tree with $\geq 2$ vertices has at least 2 leaves.

  \item Use Prim's algorithm to find an MST (create your own example).

  \item Prove that every tree is bipartite.

  \item Give BFS and DFS spanning trees of $C_4$ starting from vertex 1.

  \item Prove: If a graph has $n$ vertices and fewer than $n - 1$ edges, it's not connected.

  \item How many spanning trees does $C_n$ have?

  \item Prove: In any tree, the sum of degrees equals $2(n-1)$.

  \item Let $X = \{1,2,3\}$, $Y = \{a,b,c\}$ with edges $\{1a, 1b, 2b, 2c, 3c\}$. Does a matching covering $X$ exist? Find one or explain why not.

  \item Find a maximum matching in the bipartite graph with $X=\{u,v,w\}$, $Y=\{x,y,z\}$, edges $\{ux, uy, vx, vy, wz\}$.

  \item Compute the maximum flow in a network with edges $s \to a$ (3), $s \to b$ (2), $a \to b$ (1), $a \to t$ (2), $b \to t$ (3). Find a minimum cut.
\end{enumerate}
